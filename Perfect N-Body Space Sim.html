<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>2D N-Body Simulation with Enhanced UI</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<style>
    /* --- Base Styles --- */
    body {
        margin: 0;
        background: #000;
        overflow: hidden;
        font-family: 'Inter', Arial, Helvetica, sans-serif;
    }
    canvas {
        display: block;
        background: #000;
    }
    button {
        cursor: pointer;
        border: none;
        outline: none;
        transition: all 0.2s ease;
    }
    input[type=range] {
        -webkit-appearance: none;
        background: transparent;
        cursor: pointer;
    }

    /* --- Sliders Panel (#ui) --- */
    #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        background: linear-gradient(135deg, rgba(40, 44, 52, 0.9), rgba(60, 64, 72, 0.9));
        color: rgba(255, 255, 255, 0.9);
        padding: 16px;
        border-radius: 12px;
        font-size: 14px;
        line-height: 1.5;
        z-index: 10;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.1);
    }
    #ui label {
        display: block;
        margin-bottom: 5px;
        font-weight: 600;
    }
    #ui label span {
        cursor: pointer;
    }
    #ui input[type=range] {
        width: 170px;
        margin-bottom: 12px;
    }
    #ui button {
        background: rgba(60, 64, 72, 0.9);
        color: #fff;
        border-radius: 8px;
        padding: 8px 12px;
        font-weight: 600;
        border: 1px solid rgba(255, 255, 255, 0.1);
    }
    #ui button:hover {
        background: rgba(80, 84, 92, 0.9);
        transform: scale(1.05);
    }
    #ui button:active {
        background: rgba(0, 123, 255, 0.9);
    }

    /* Custom Slider Track */
    input[type=range]::-webkit-slider-runnable-track {
        background: rgba(255, 255, 255, 0.2);
        height: 6px;
        border-radius: 4px;
    }
    input[type=range]::-moz-range-track {
        background: rgba(255, 255, 255, 0.2);
        height: 6px;
        border-radius: 4px;
    }

    /* Custom Slider Thumb */
    input[type=range]::-webkit-slider-thumb {
        -webkit-appearance: none;
        margin-top: -5px; /* Vertically center */
        height: 16px;
        width: 16px;
        border-radius: 50%;
        background: rgba(0, 123, 255, 0.9);
        border: 2px solid #fff;
        transition: all 0.2s ease;
    }
    input[type=range]::-webkit-slider-thumb:hover {
        box-shadow: 0 0 8px rgba(0, 123, 255, 0.7);
        transform: scale(1.1);
    }
    input[type=range]::-moz-range-thumb {
        height: 16px;
        width: 16px;
        border-radius: 50%;
        background: rgba(0, 123, 255, 0.9);
        border: 2px solid #fff;
        transition: all 0.2s ease;
    }
    input[type=range]::-moz-range-thumb:hover {
        box-shadow: 0 0 8px rgba(0, 123, 255, 0.7);
    }

    /* Inline Input for Slider Values */
    .value-input {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(0, 123, 255, 0.8);
        border-radius: 4px;
        color: #fff;
        padding: 1px 4px;
        outline: none;
        box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
        font-family: inherit;
        font-size: inherit;
        width: 60px;
        text-align: right;
    }

    /* --- Object List Panel --- */
    #object-list-container {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 280px; /* Increased width for padding */
        height: calc(100vh - 20px);
        background: linear-gradient(135deg, rgba(40, 44, 52, 0.9), rgba(60, 64, 72, 0.9));
        color: #fff;
        border-radius: 12px;
        padding: 10px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        font-size: 13px;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.1);
    }
    #object-list-container h3 {
        margin: 5px 0 15px 0;
        text-align: center;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.9);
    }
    #object-list {
        flex-grow: 1;
        overflow-y: auto;
        padding-right: 8px; /* Space for scrollbar */
    }
    .object-item {
        display: flex;
        align-items: center;
        padding: 8px;
        margin-bottom: 6px; /* Increased spacing */
        border-radius: 8px; /* Rounded items */
        border: none;
        background: rgba(255, 255, 255, 0.05);
        cursor: pointer;
        transition: background 0.2s ease;
    }
    .object-item:hover {
        background: rgba(255, 255, 255, 0.15);
    }
    .object-item.tracked {
        background: rgba(0, 123, 255, 0.3);
        box-shadow: 0 0 8px rgba(0, 123, 255, 0.5);
        border-left: none;
    }
    .object-item .color-swatch {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        margin-right: 12px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        flex-shrink: 0;
    }
    .object-item .info { flex-grow: 1; }
    .object-item .info div { line-height: 1.4; color: rgba(255, 255, 255, 0.8); }
    .object-item .info b { color: #fff; font-weight: 600; }
    .delete-btn, .edit-btn, .toggle-vis-btn {
        width: 24px;
        height: 24px;
        line-height: 24px;
        border-radius: 50%;
        color: #fff;
        border: none;
        margin-left: 6px;
        flex-shrink: 0;
        padding: 0;
        font-size: 14px;
        transition: all 0.2s ease;
    }
    .delete-btn { background: rgba(255, 85, 85, 0.8); }
    .edit-btn { background: rgba(0, 123, 255, 0.8); }
    .toggle-vis-btn { background: rgba(100, 100, 100, 0.8); }
    .delete-btn:hover, .edit-btn:hover, .toggle-vis-btn:hover {
        transform: scale(1.1);
        filter: brightness(1.2);
    }

    /* Custom Scrollbar for Object List */
    #object-list::-webkit-scrollbar { width: 6px; }
    #object-list::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.2); border-radius: 3px; }
    #object-list::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.3); border-radius: 3px; }
    #object-list::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.5); }


    /* --- Utilities Toolbar --- */
    #utilities-container {
        position: absolute;
        bottom: 10px;
        left: 220px; /* Positioned next to sliders */
        display: flex;
        align-items: flex-end;
    }
    #utilitiesButton {
        padding: 12px 20px;
        border-radius: 8px;
        background: rgba(0, 123, 255, 0.8);
        color: #fff;
        font-weight: 600;
        border: 1px solid rgba(255, 255, 255, 0.2);
        transition: all 0.3s ease;
    }
    #utilitiesButton:hover {
        box-shadow: 0 0 10px rgba(0, 123, 255, 0.5);
        transform: translateY(-2px);
    }
    #utilitiesToolbar {
        display: flex;
        background: linear-gradient(135deg, rgba(40, 44, 52, 0.9), rgba(60, 64, 72, 0.9));
        border-radius: 12px;
        padding: 5px;
        margin-left: 10px;
        max-width: 0;
        opacity: 0;
        overflow: hidden;
        transition: max-width 0.4s ease, opacity 0.3s ease, padding 0.4s ease;
        white-space: nowrap;
        border: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(5px);
    }
    #utilitiesToolbar.expanded {
        max-width: 800px;
        opacity: 1;
        overflow-x: auto;
    }
    #utilitiesToolbar button {
        padding: 10px 16px;
        margin: 4px;
        flex-shrink: 0;
        border-radius: 8px;
        background: rgba(60, 64, 72, 0.9);
        color: #fff;
        font-weight: 600;
    }
    #utilitiesToolbar button:hover {
        background: rgba(80, 84, 92, 0.9);
        transform: scale(1.05);
    }
    .tool-btn.active {
        background: rgba(0, 123, 255, 0.9);
        color: white;
        border-color: transparent;
        box-shadow: 0 0 8px rgba(0, 123, 255, 0.5);
    }
    .tool-btn.disabled {
        opacity: 0.5;
        cursor: not-allowed;
        pointer-events: none;
    }

    /* --- Modal Panels (Edit, Save/Load, Presets) --- */
    #edit-panel, #save-load-panel, #presets-panel {
        position: absolute;
        background: linear-gradient(135deg, rgba(30, 34, 42, 0.95), rgba(50, 54, 62, 0.95));
        color: #fff;
        padding: 20px;
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        z-index: 20;
        display: none;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(8px);
    }
    #edit-panel { width: 240px; }

    #edit-panel h4, #save-load-panel h4, #presets-panel h4 {
        margin-top: 0;
        padding-bottom: 15px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        cursor: move;
        user-select: none;
        font-weight: 600;
        font-size: 18px;
    }
    #edit-panel label { display: block; margin-top: 15px; font-weight: 600; }
    #edit-panel input {
        width: 100%;
        box-sizing: border-box;
        margin-top: 8px;
        padding: 10px;
        border-radius: 6px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.3);
        color: #fff;
        outline: none;
        transition: all 0.2s ease;
    }
    #edit-panel input:focus {
        border-color: rgba(0, 123, 255, 0.8);
        box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
    }
    #edit-panel input[type=color] {
        padding: 5px; /* Special padding for color input */
        height: 40px;
    }
    #edit-panel button {
        margin-top: 20px;
        border-radius: 8px;
        padding: 10px 15px;
        color: #fff;
        font-weight: 600;
    }
    #saveEditBtn { background: rgba(0, 123, 255, 0.8); }
    #cancelEditBtn { background: rgba(255, 85, 85, 0.8); }
    #edit-panel button:hover {
        transform: scale(1.05);
        filter: brightness(1.2);
    }
    
    /* --- Save & Load / Presets Panel --- */
    #save-load-panel { width: 320px; height: 480px; flex-direction: column; }
    #presets-panel { width: 360px; height: 520px; flex-direction: column; }
    
    #save-load-panel h4, #presets-panel h4 { display: flex; justify-content: space-between; align-items: center; }
    
    #closeSaveLoadBtn, #closePresetsBtn {
        background: transparent; border: none; color: #fff; font-size: 24px; font-weight: 300; line-height: 1; padding: 0 5px; opacity: 0.7;
    }
    #closeSaveLoadBtn:hover, #closePresetsBtn:hover { opacity: 1; }
    
    .panel-section { padding: 20px 0; }
    #presets-panel .panel-section { padding: 10px 20px; flex-grow: 1; overflow-y: auto; }

    .panel-divider { border: none; border-top: 1px solid rgba(255, 255, 255, 0.15); margin: 0; }
    
    #save-load-panel h5 { margin-top: 0; margin-bottom: 25px; font-size: 16px; font-weight: 600; color: rgba(255,255,255,0.9); text-align: center; }
    
    #save-load-panel button, .preset-item-btn {
        width: 100%; box-sizing: border-box; padding: 12px; border-radius: 8px; font-weight: 600; font-size: 15px; border: 1px solid rgba(255, 255, 255, 0.1);
    }
    #save-load-panel button:hover, .preset-item-btn:hover { transform: scale(1.03); filter: brightness(1.1); }
    
    #saveSimBtn, .preset-item-btn { background: rgba(0, 123, 255, 0.8); margin-bottom: 12px; }
    #loadSimBtn { background: rgba(40, 167, 69, 0.8); }
    #chooseFileBtn { background: rgba(108, 117, 125, 0.8); }
    
    .file-input-wrapper { margin-bottom: 20px; }
    #fileNameSpan { display: block; margin-top: 15px; padding: 0 10px; font-style: italic; color: rgba(255,255,255,0.7); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 14px; }

    /* --- Tooltip --- */
    .tooltip {
        position: absolute;
        background: rgba(30, 34, 42, 0.95);
        color: rgba(255, 255, 255, 0.9);
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 12px;
        line-height: 1.4;
        max-width: 200px;
        text-align: center;
        white-space: normal;
        z-index: 100;
        opacity: 0;
        pointer-events: none;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(8px);
        transition: opacity 0.2s ease, transform 0.2s ease;
        transform: translateX(-50%) scale(0.95);
    }
    .tooltip.show {
        opacity: 1;
        transform: translateX(-50%) scale(1);
    }
    .tooltip.below {
        transform: translateX(-50%) scale(0.95);
    }
    .tooltip.below.show {
        transform: translateX(-50%) scale(1);
    }
    .tooltip::after {
        content: '';
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        border-width: 5px;
        border-style: solid;
        border-color: rgba(30, 34, 42, 0.95) transparent transparent transparent;
    }
    .tooltip.below::after {
        top: auto;
        bottom: 100%;
        border-color: transparent transparent rgba(30, 34, 42, 0.95) transparent;
    }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div id="ui">
    <label>Gravity Strength: <span id="gravityValue">200</span></label>
    <input type="range" id="gravitySlider" min="0.1" max="670" step="0.1" value="200">

    <label>Gravity Multiplier: <span id="gravityMultValue">10</span>×</label>
    <input type="range" id="gravityMultSlider" min="0.1" max="100" step="0.1" value="10">

    <label>Time Speed: <span id="timeValue">1.0</span>×</label>
    <input type="range" id="timeSlider" min="0.1" max="150" step="0.1" value="1.0">

    <label>Spawn Mass: <span id="spawnMassValue">10</span></label>
    <input type="range" id="spawnMassSlider" min="1" max="1000" step="1" value="10">

    <label>Throw Speed Multiplier: <span id="throwSpeedMultValue">10.0</span>×</label>
    <input type="range" id="throwSpeedMultSlider" min="0.1" max="100" step="0.1" value="10">

    <label>Path Length: <span id="pathLengthValue">550</span></label>
    <input type="range" id="pathLengthSlider" min="1" max="100000" step="1" value="550">

    <div>
        <button id="clearAllButton">Clear All</button>
        <button id="resetAllButton">Reset All Sliders</button>
        <button id="pauseButton">Pause</button>
    </div>
</div>

<div id="object-list-container">
    <h3>Object List</h3>
    <div id="object-list"></div>
</div>

<div id="utilities-container">
    <button id="utilitiesButton">Utilities</button>
    <div id="utilitiesToolbar">
        <button id="trackerBtn" class="tool-btn">Planet Tracker</button>
        <button id="addVelBtn" class="tool-btn">Add Velocity</button>
        <button id="anchorBtn" class="tool-btn">Anchor</button>
        <button id="autoOrbitBtn" class="tool-btn">Auto Orbit</button>
        <button id="trailsBtn" class="tool-btn">Planet Trails</button>
        <button id="relTrailBtn" class="tool-btn">Rel. Trail</button>
        <button id="orbitBtn" class="tool-btn">Displayed Orbit</button>
        <button id="editorBtn" class="tool-btn">Planet Editor</button>
        <button id="barycenterBtn" class="tool-btn">Barycenter</button>
        <button id="saveLoadBtn" class="tool-btn">Save & Load</button>
        <button id="presetsBtn" class="tool-btn">Presets</button>
    </div>
</div>

<div id="edit-panel">
    <h4 id="edit-panel-header">Edit Object</h4>
    <input type="hidden" id="edit-id">
    <label for="edit-name">Name</label>
    <input type="text" id="edit-name">
    <label for="edit-mass">Mass</label>
    <input type="number" id="edit-mass" min="1">
    <label for="edit-color">Color</label>
    <input type="color" id="edit-color">
    <button id="saveEditBtn">Save</button>
    <button id="cancelEditBtn">Cancel</button>
</div>

<div id="save-load-panel">
    <h4 id="save-load-panel-header">Save & Load Simulation <button id="closeSaveLoadBtn">&times;</button></h4>
    <div class="panel-section">
        <button id="saveSimBtn">Save Current Simulation</button>
    </div>
    <hr class="panel-divider">
    <div class="panel-section">
        <h5 style="text-align:center;">Load Simulation</h5>
        <div class="file-input-wrapper">
            <button id="chooseFileBtn">Choose File</button>
            <span id="fileNameSpan">no file chosen</span>
            <input type="file" id="loadFileInput" accept=".json" style="display: none;">
        </div>
        <button id="loadSimBtn">Load</button>
    </div>
</div>

<div id="presets-panel">
    <h4 id="presets-panel-header">Presets <button id="closePresetsBtn">&times;</button></h4>
    <div class="panel-section" id="presets-container">
        <!-- Preset buttons will be dynamically inserted here -->
    </div>
</div>

<script>
/* ---------- defaults ---------- */
const DEFAULT_G = 200, DEFAULT_GM = 10, DEFAULT_TS = 1.0, DEFAULT_SM = 10, DEFAULT_TSM = 10, DEFAULT_ZOOM = 1, DEFAULT_PATH_MULT = 550;

/* ---------- canvas ---------- */
const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
resize(); addEventListener('resize', resize);

/* ---------- view transform ---------- */
let zoom = DEFAULT_ZOOM, viewX = 0, viewY = 0;
function worldToScreen(wx, wy){ return { x:(wx - viewX)*zoom + canvas.width/2, y:(wy - viewY)*zoom + canvas.height/2 }; }
function screenToWorld(sx, sy){ return { x:(sx - canvas.width/2)/zoom + viewX, y:(sy - canvas.height/2)/zoom + viewY }; }
function applyView(){ ctx.setTransform(zoom, 0, 0, zoom, -viewX*zoom + canvas.width/2, -viewY*zoom + canvas.height/2); }

/* ---------- physics constants ---------- */
const BASE_DT = 0.01, SUBST = 8, SOFT = 0.03, REST = 0.3, BOUNCE = 0.9;
const GSIZE = 40, COL_IT = 3, THETA = 0.5;
const PREDICTION_THETA = 1.2;
const REF_DIAMETER = 2 * Math.sqrt(10);

/* ---------- particle ---------- */
let nextId = 1;
let bodyNameCounter = 1;
class P{
    constructor(x,y,m=1,vx=0,vy=0){
        this.id = nextId++;
        this.name = null;
        this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.m=m; this.r=Math.sqrt(this.m);
        this.ax=0; this.ay=0; this.merged=false;
        this.customColor = null;
        this.anchored = false;
        this.trail = [];
        this.isBarycenter = false;
        this.connectedIds = [];
        this.visible = true;
    }
    color(){
        if(this.customColor) return this.customColor;
        const hue = (Math.log10(this.m) * 180) % 360;
        return `hsl(${hue}, 90%, 65%)`;
    }
}
let ps = [];
function resetPs(){ ps=[]; nextId = 1; bodyNameCounter = 1; resetHistory(); }
function cloneParticle(p) {
    const clone = Object.assign(new P(0,0), JSON.parse(JSON.stringify(p)));
    return clone;
}

/* ---------- state variables ---------- */
let trackedParticle = null;
let planetTrackerMode = false, planetEditorMode = false, addVelocityMode = false, anchorMode = false, barycenterMode = false, autoOrbitMode = false;
let trailsEnabled = false, orbitPredictionEnabled = false, relativeTrailsEnabled = false;
let selectedParticles = new Set();
let selectionBox = {world: null, screen: null};
let barycenterBoxDrawing = false;
let addVelToolState = 'idle'; // 'idle', 'drawing', 'locked', 'applyingVelocity'
let lockedBoxDragStart = {};
let currentlyEditing = null;
let predictedPaths = new Map();
let spawnPreviewPath = [];
let isPaused = false;
let PATH_LENGTH_MULTIPLIER = DEFAULT_PATH_MULT;
let frameCounter = 0;

/* ---------- Undo/Redo System ---------- */
const MAX_HISTORY = 50;
let historyStack = [];
let redoStack = [];

function recordHistory(action) {
    redoStack = [];
    historyStack.push(action);
    if (historyStack.length > MAX_HISTORY) {
        historyStack.shift();
    }
}

function undo() {
    if (historyStack.length === 0) return;
    const action = historyStack.pop();
    redoStack.push(action);

    switch(action.type) {
        case 'spawn': ps = ps.filter(p => p.id !== action.particle.id); break;
        case 'delete': ps.push(action.particle); break;
        case 'edit': case 'addVelocity': case 'anchor':
            let p_undo = ps.find(p => p.id === action.before.id);
            if (p_undo) Object.assign(p_undo, action.before);
            break;
        case 'batchEdit':
            action.before.forEach(state => {
                const p = ps.find(p => p.id === state.id);
                if (p) Object.assign(p, state);
            });
            break;
        case 'batchDelete':
            action.particles.forEach(p => ps.push(p));
            break;
    }
}

function redo() {
    if (redoStack.length === 0) return;
    const action = redoStack.pop();
    historyStack.push(action);

    switch(action.type) {
        case 'spawn': ps.push(action.particle); break;
        case 'delete': ps = ps.filter(p => p.id !== action.particle.id); break;
        case 'edit': case 'addVelocity': case 'anchor':
            let p_redo = ps.find(p => p.id === action.after.id);
            if (p_redo) Object.assign(p_redo, action.after);
            break;
        case 'batchEdit':
            action.after.forEach(state => {
                const p = ps.find(p => p.id === state.id);
                if (p) Object.assign(p, state);
            });
            break;
        case 'batchDelete':
            const idsToDelete = new Set(action.particles.map(p => p.id));
            ps = ps.filter(p => !idsToDelete.has(p.id));
            break;
    }
}

function resetHistory() {
    historyStack = [];
    redoStack = [];
}

/* ---------- spatial grid / collisions ---------- */
function key(x,y){ return `${Math.floor(x/GSIZE)},${Math.floor(y/GSIZE)}`; }
function buildGrid(particleList){
    const g=new Map();
    for(const p of particleList){ const k=key(p.x,p.y); if(!g.has(k)) g.set(k,[]); g.get(k).push(p); }
    return g;
}
function nearby(p,g){
    const out=[];
    const x_base = Math.floor(p.x/GSIZE), y_base = Math.floor(p.y/GSIZE);
    const searchDist = Math.ceil(p.r / GSIZE);

    for(let dy = -searchDist; dy <= searchDist; dy++) {
        for(let dx = -searchDist; dx <= searchDist; dx++) {
            const kk = `${x_base + dx},${y_base + dy}`;
            if(g.has(kk)) {
                out.push(...g.get(kk));
            }
        }
    }
    return out;
}
function handleMerges(particleList) {
    for (let it = 0; it < COL_IT; it++) {
        const g = buildGrid(particleList.filter(p => !p.isBarycenter));
        for (let i = 0; i < particleList.length; i++) {
            const p1 = particleList[i];
            if (p1.merged || p1.isBarycenter) continue;
            const nears = nearby(p1, g).filter(p2 => particleList.indexOf(p2) > i && !p2.merged);
            
            for (const p2 of nears) {
                const dx = p2.x - p1.x, dy = p2.y - p1.y;
                const d_sq = dx * dx + dy * dy;

                if (d_sq < 1e-9) {
                    let absorber = p1, absorbee = p2;
                    if (p1.m < p2.m) { [absorber, absorbee] = [p2, p1]; }
                    if (p1.anchored && !p2.anchored) { [absorber, absorbee] = [p1, p2]; }
                    if (p2.anchored && !p1.anchored) { [absorber, absorbee] = [p2, p1]; }
                    
                    const newM = absorber.m + absorbee.m;
                    if (!absorber.anchored) {
                        absorber.vx = (absorber.vx * absorber.m + absorbee.vx * absorbee.m) / newM;
                        absorber.vy = (absorber.vy * absorber.m + absorbee.vy * absorbee.m) / newM;
                    }
                    absorber.m = newM;
                    absorber.r = Math.sqrt(absorber.m);
                    absorbee.merged = true;

                    if (absorbee === p1) { break; } 
                    else { continue; }
                }

                const d = Math.sqrt(d_sq);
                if (d <= p1.r + p2.r) {
                    let absorber = p1, absorbee = p2;
                    if (p1.m < p2.m && !p1.anchored) { [absorber, absorbee] = [p2, p1]; }
                    if (p2.anchored) { [absorber, absorbee] = [p2, p1]; }

                    const newM = absorber.m + absorbee.m;
                    if (!absorber.anchored) {
                        absorber.x = (absorber.x * absorber.m + absorbee.x * absorbee.m) / newM;
                        absorber.y = (absorber.y * absorber.m + absorbee.y * absorbee.m) / newM;
                        absorber.vx = (absorber.vx * absorber.m + absorbee.vx * absorbee.m) / newM;
                        absorber.vy = (absorber.vy * absorber.m + absorbee.vy * absorbee.m) / newM;
                    }
                    absorber.m = newM;
                    absorber.r = Math.sqrt(absorber.m);
                    absorbee.merged = true;

                    if (absorbee === p1) break;
                }
            }
        }
    }
    return particleList.filter(p => !p.merged);
}


/* ---------- quadtree for barnes-hut ---------- */
class Quad{
    constructor(bounds){ this.bounds=bounds; this.mass=0; this.comX=0; this.comY=0; this.p=null; this.children=null; }
    insert(p){
        if(!p || this.p === p) return;
        const newMass = this.mass + p.m;
        this.comX = (this.comX * this.mass + p.x * p.m) / newMass;
        this.comY = (this.comY * this.mass + p.y * p.m) / newMass;
        this.mass = newMass;

        if(this.children){
            this.children[this.getIdx(p.x,p.y)].insert(p);
        }else if(this.p){
            const w2=this.bounds.w/2, h2=this.bounds.h/2;
            this.children=[
                new Quad({x:this.bounds.x,y:this.bounds.y,w:w2,h:h2}),
                new Quad({x:this.bounds.x+w2,y:this.bounds.y,w:w2,h:h2}),
                new Quad({x:this.bounds.x,y:this.bounds.y+h2,w:w2,h:h2}),
                new Quad({x:this.bounds.x+w2,y:this.bounds.y+h2,w:w2,h:h2})
            ];
            this.children[this.getIdx(this.p.x,this.p.y)].insert(this.p);
            this.children[this.getIdx(p.x,p.y)].insert(p);
            this.p=null;
        }else{
            this.p=p;
        }
    }
    getIdx(x,y){
        let idx=0;
        if(x >= this.bounds.x + this.bounds.w/2) idx+=1;
        if(y >= this.bounds.y + this.bounds.h/2) idx+=2;
        return idx;
    }
}
function calcForce(qt, p, theta, G, soft){
    if(!qt || qt.mass===0) return {ax: 0, ay: 0};
    const dx=qt.comX - p.x, dy=qt.comY - p.y;
    const d2=dx*dx + dy*dy + soft*soft;
    let ax = 0, ay = 0;

    if(qt.children !== null){
        const s=qt.bounds.w;
        const d=Math.sqrt(d2);
        if(s / d < theta){
            const f=G * qt.mass / (d2 * d);
            ax += f * dx;
            ay += f * dy;
        }else{
            for(const child of qt.children) {
                const force = calcForce(child, p, theta, G, soft);
                ax += force.ax;
                ay += force.ay;
            }
        }
    }else if(qt.p && qt.p !== p){
        const d=Math.sqrt(d2);
        const f=G * qt.mass / (d2 * d);
        ax += f * dx;
        ay += f * dy;
    }
    return {ax, ay};
}
function buildQuadTree(particleList){
    if(particleList.length===0) return null;
    let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
    for(const p of particleList){
        minX=Math.min(minX,p.x); maxX=Math.max(maxX,p.x);
        minY=Math.min(minY,p.y); maxY=Math.max(maxY,p.y);
    }
    let side=Math.max(maxX-minX, maxY-minY) || 100;
    side *= 1.2;
    const cx=(minX+maxX)/2, cy=(minY+maxY)/2;
    const bounds={x:cx-side/2, y:cy-side/2, w:side, h:side};
    const qt=new Quad(bounds);
    for(const p of particleList.filter(p => !p.isBarycenter)) qt.insert(p);
    return qt;
}

/* ---------- Dynamic Object Updates ---------- */
function updateBarycenters() {
    for (const p of ps) {
        if (!p.isBarycenter) continue;

        const connectedParticles = [];
        p.connectedIds = p.connectedIds.filter(id => {
            const connectedP = ps.find(part => part.id === id);
            if (connectedP) {
                connectedParticles.push(connectedP);
                return true;
            }
            return false;
        });

        if (connectedParticles.length < 2) {
            p.merged = true; // Mark for automatic deletion
            continue;
        }

        let totalMass = 0;
        let comX = 0;
        let comY = 0;

        for (const connectedP of connectedParticles) {
            totalMass += connectedP.m;
            comX += connectedP.m * connectedP.x;
            comY += connectedP.m * connectedP.y;
        }

        if (totalMass > 0) {
            p.m = totalMass;
            p.x = comX / totalMass;
            p.y = comY / totalMass;
        } else {
            p.merged = true;
        }
    }
}


/* ---------- step ---------- */
let G = DEFAULT_G, GM=DEFAULT_GM, TS=DEFAULT_TS;
function step(){
    const dt=BASE_DT*TS/SUBST, EG=G*GM;
    
    if(!trailsEnabled && !relativeTrailsEnabled) {
        for(const p of ps) p.trail = [];
    }
    
    for(let s=0;s<SUBST;s++){
        const qt=buildQuadTree(ps);
        for(const p of ps){
            if (p.anchored || p.isBarycenter) {
                p.ax = 0; p.ay = 0;
                continue;
            }
            const {ax, ay} = qt ? calcForce(qt, p, THETA, EG, SOFT) : {ax:0, ay:0};
            p.ax = ax; p.ay = ay;
        }
        for(const p of ps){
            if (p.anchored || p.isBarycenter) continue;
            p.vx += p.ax * dt;
            p.vy += p.ay * dt;
        }
        
        ps = handleMerges(ps);
        updateBarycenters();

        for(const p of ps){
            if (p.anchored || p.isBarycenter) continue;
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            if(isNaN(p.x)||isNaN(p.y)){ p.x=0; p.y=0; p.vx=p.vy=0; }
            
            if (trailsEnabled || (relativeTrailsEnabled && trackedParticle)) {
                let newPoint;
                if (trailsEnabled) { newPoint = {x: p.x, y: p.y}; } 
                else {
                    if (p === trackedParticle) { p.trail = []; continue; } 
                    else { newPoint = { x: p.x - trackedParticle.x, y: p.y - trackedParticle.y }; }
                }

                const lastPoint = p.trail[p.trail.length - 1];
                if (!lastPoint || (Math.sqrt(Math.pow(newPoint.x - lastPoint.x, 2) + Math.pow(newPoint.y - lastPoint.y, 2)) > 2)) {
                    p.trail.push(newPoint);
                }
                
                if (p.trail.length > 10000) p.trail.shift();
                
                const targetWorldLength = PATH_LENGTH_MULTIPLIER * REF_DIAMETER;
                let currentTrailLength = 0;
                let keepIndex = p.trail.length - 1;
                for (let i = p.trail.length - 2; i >= 0; i--) {
                    const seg_dx = p.trail[i+1].x - p.trail[i].x;
                    const seg_dy = p.trail[i+1].y - p.trail[i].y;
                    currentTrailLength += Math.sqrt(seg_dx*seg_dx + seg_dy*seg_dy);
                    if (currentTrailLength > targetWorldLength) {
                        keepIndex = i + 1;
                        break;
                    }
                    keepIndex = i;
                }
                if (keepIndex > 0) p.trail.splice(0, keepIndex);
            }
        }
    }
}

/* ---------- Orbit Prediction ---------- */
const PRED_MAX_STEPS = 1000;

function predictSpawnPath(initialGhost, existingParticles, relativeToParticle = null) {
    if (!orbitPredictionEnabled) return [];

    const PRED_STEP_INTERVAL = 5;
    const EG = G * GM;
    const dt_pred = BASE_DT / 2;
    const duration = PATH_LENGTH_MULTIPLIER * REF_DIAMETER / 10;
    const totalSteps = Math.min(PRED_MAX_STEPS, Math.floor(duration / dt_pred));

    let ghosts = existingParticles.map(p => ({
        id: p.id, x: p.x, y: p.y, vx: p.vx, vy: p.vy, m: p.m,
        anchored: p.anchored, isBarycenter: p.isBarycenter
    }));
    
    const newGhost = { ...initialGhost, id: -1, path: [] };
    ghosts.push(newGhost);

    let trackedGhost = null;
    let trackedGhostPath = [];
    if (relativeToParticle) {
        trackedGhost = ghosts.find(g => g.id === relativeToParticle.id);
    }

    for (let step = 0; step < totalSteps; step++) {
        const qt = buildQuadTree(ghosts);
        for (const ghost of ghosts) {
            if (ghost.anchored || ghost.isBarycenter) continue;
            const { ax, ay } = qt ? calcForce(qt, ghost, THETA, EG, SOFT) : { ax: 0, ay: 0 };
            ghost.vx += ax * dt_pred;
            ghost.vy += ay * dt_pred;
            ghost.x += ghost.vx * dt_pred;
            ghost.y += ghost.vy * dt_pred;
        }

        if (step % PRED_STEP_INTERVAL === 0) {
            newGhost.path.push({ x: newGhost.x, y: newGhost.y });
            if (trackedGhost) {
                trackedGhostPath.push({ x: trackedGhost.x, y: trackedGhost.y });
            }
        }
    }

    if (trackedGhost) {
        if (trackedGhostPath.length === 0) return newGhost.path;
        const trackedInitialPos = { x: relativeToParticle.x, y: relativeToParticle.y };
        const relativePath = newGhost.path.map((point, i) => {
            let trackedPoint = trackedGhost.anchored ? {x: trackedGhost.x, y: trackedGhost.y} : (trackedGhostPath[i] || trackedGhostPath[trackedGhostPath.length - 1]);
            return {
                x: trackedInitialPos.x + (point.x - trackedPoint.x),
                y: trackedInitialPos.y + (point.y - trackedPoint.y)
            };
        });
        return relativePath;
    } else {
        return newGhost.path;
    }
}


function predictAllOrbits() {
    predictedPaths.clear();
    if (ps.length === 0 || !orbitPredictionEnabled) return;

    const PRED_STEP_INTERVAL = 5;
    const EG = G * GM;
    const dt_pred = BASE_DT / 2;
    const duration = PATH_LENGTH_MULTIPLIER * REF_DIAMETER / 10;
    const totalSteps = Math.min(PRED_MAX_STEPS, Math.floor(duration / dt_pred));

    let ghosts = ps.map(p => ({
        id: p.id, x: p.x, y: p.y, vx: p.vx, vy: p.vy, m: p.m,
        anchored: p.anchored, path: [], isBarycenter: p.isBarycenter
    }));

    let trackedGhost = trackedParticle ? ghosts.find(g => g.id === trackedParticle.id) : null;

    for (let step = 0; step < totalSteps; step++) {
        const qt = buildQuadTree(ghosts);
        for (const ghost of ghosts) {
            if (ghost.anchored || ghost.isBarycenter) continue;
            const { ax, ay } = qt ? calcForce(qt, ghost, THETA, EG, SOFT) : { ax: 0, ay: 0 };
            ghost.vx += ax * dt_pred;
            ghost.vy += ay * dt_pred;
            ghost.x += ghost.vx * dt_pred;
            ghost.y += ghost.vy * dt_pred;
        }

        if (step % PRED_STEP_INTERVAL === 0) {
            for (const ghost of ghosts) {
                if (ghost.anchored || ghost.isBarycenter) continue;
                ghost.path.push({ x: ghost.x, y: ghost.y });
            }
        }
    }

    if (trackedGhost) {
        const trackedPath = trackedGhost.path;
        if (trackedPath.length === 0 && !trackedGhost.anchored) return;
        
        const trackedInitialPos = { x: trackedParticle.x, y: trackedParticle.y };

        for (const ghost of ghosts) {
            if (ghost.id === trackedParticle.id || ghost.isBarycenter) continue;
            if (ghost.path.length === 0) continue;

            const relativePath = ghost.path.map((point, i) => {
                let trackedPoint = trackedGhost.anchored ? {x: trackedGhost.x, y: trackedGhost.y} : (trackedPath[i] || trackedPath[trackedPath.length - 1]);
                return {
                    x: trackedInitialPos.x + (point.x - trackedPoint.x),
                    y: trackedInitialPos.y + (point.y - trackedPoint.y)
                };
            });
            predictedPaths.set(ghost.id, relativePath);
        }
    } else {
        for (const ghost of ghosts) {
            if (ghost.path.length > 0 && !ghost.isBarycenter) {
                predictedPaths.set(ghost.id, ghost.path);
            }
        }
    }
}


/* ---------- draw ---------- */
let dragging=false, isPanning=false, sx,sy,cx,cy, lastX, lastY, SPAWN_MASS=DEFAULT_SM, THROW_MULT=DEFAULT_TSM;
let addVelTarget = null;

function draw(){
    frameCounter++;

    // Real-time UI state updates
    const autoOrbitBtn = $('autoOrbitBtn');
    const autoOrbitEligible = trackedParticle && !trackedParticle.isBarycenter && trackedParticle.m > 0;
    if (autoOrbitEligible) {
        autoOrbitBtn.classList.remove('disabled');
    } else {
        autoOrbitBtn.classList.add('disabled');
        if (autoOrbitMode) {
            autoOrbitMode = false;
            autoOrbitBtn.classList.remove('active');
        }
    }
    
    if (trackedParticle && !ps.find(p => p.id === trackedParticle.id)) {
        setTrackedParticle(null);
    }
    
    ctx.save();
    ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
    if(trackedParticle) { viewX = trackedParticle.x; viewY = trackedParticle.y; }
    applyView();

    ctx.save();
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';

    if (barycenterMode && selectedParticles.size > 0) {
        ctx.strokeStyle = '#800080'; // Purple
        ctx.lineWidth = 2 / zoom;
        for (const p of selectedParticles) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r + 2 / zoom, 0, Math.PI * 2);
            ctx.stroke();
        }
    }
    
    if (autoOrbitMode && autoOrbitEligible) {
        const mouseWorld = screenToWorld(cx, cy);
        const r = Math.hypot(mouseWorld.x - trackedParticle.x, mouseWorld.y - trackedParticle.y);
        ctx.beginPath();
        ctx.arc(trackedParticle.x, trackedParticle.y, r, 0, Math.PI * 2);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1 / zoom;
        ctx.setLineDash([5 / zoom, 5 / zoom]);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    if (orbitPredictionEnabled) {
        ctx.lineWidth = Math.max(0.5, 1.2 / zoom); 
        for(const p of ps) {
            const path = predictedPaths.get(p.id);
            if (path && path.length > 1) {
                const baseColor = p.color();
                for (let i = 1; i < path.length; i++) {
                    const alpha = 0.7 - (0.4 * (i / path.length));
                    ctx.beginPath();
                    ctx.moveTo(path[i-1].x, path[i-1].y);
                    ctx.lineTo(path[i].x, path[i].y);
                    ctx.strokeStyle = baseColor.replace('hsl', 'hsla').replace(')', `, ${alpha})`);
                    ctx.stroke();
                }
            }
        }
    }

    const isDrawingTrails = trailsEnabled || (relativeTrailsEnabled && trackedParticle);
    if (isDrawingTrails) {
        ctx.lineWidth = Math.max(0.5, 1.0 / zoom);
        for (const p of ps) {
            const trail = p.trail;
            if (trail.length < 2 || p.isBarycenter || (relativeTrailsEnabled && p === trackedParticle)) continue;

            const refX = relativeTrailsEnabled ? trackedParticle.x : 0;
            const refY = relativeTrailsEnabled ? trackedParticle.y : 0;
            
            ctx.beginPath();
            ctx.moveTo(refX + trail[0].x, refY + trail[0].y);
            for(let i = 1; i < trail.length; i++) {
                ctx.lineTo(refX + trail[i].x, refY + trail[i].y);
            }
            ctx.strokeStyle = p.color();
            ctx.stroke();
        }
    }
    ctx.restore();

    for(const p of ps){
        if(isNaN(p.x)||isNaN(p.y)) continue;
        
        if (p.isBarycenter) {
            if (p.visible) {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 6 / zoom, 0, Math.PI * 2);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5 / zoom;
                ctx.stroke();
            }
        } else {
            if (p.r * zoom < 0.5) continue;
            ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fillStyle=p.color(); ctx.fill();
            if (p.anchored) {
                ctx.strokeStyle = '#00f0ff'; ctx.lineWidth = p.r * 0.15; ctx.stroke();
            }
        }
    }
    ctx.restore();

    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    
    if (dragging && spawnPreviewPath.length > 1 && orbitPredictionEnabled) {
        const screenPath = spawnPreviewPath.map(p => worldToScreen(p.x, p.y));
        for (let i = 1; i < screenPath.length; i++) {
            const alpha = 0.8 - (0.6 * (i / screenPath.length));
            ctx.beginPath();
            ctx.moveTo(screenPath[i-1].x, screenPath[i-1].y);
            ctx.lineTo(screenPath[i].x, screenPath[i].y);
            ctx.strokeStyle = `rgba(0, 255, 100, ${alpha})`;
            ctx.lineWidth = 2.0;
            ctx.stroke();
        }
    }
    
    if (dragging || addVelTarget) {
        let startX, startY;
        if (addVelTarget) {
            const sPos = worldToScreen(addVelTarget.x, addVelTarget.y);
            startX = sPos.x; startY = sPos.y;
        } else {
            startX = sx; startY = sy;
        }
        
        ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(cx, cy);
        ctx.strokeStyle = 'rgba(255,255,255,.5)'; ctx.lineWidth = 3; ctx.stroke();
        
        const preview_mult = addVelTarget ? 0.3 : 0.5;
        const vx = (startX - cx) * preview_mult * THROW_MULT;
        const vy = (startY - cy) * preview_mult * THROW_MULT;
        ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(startX + vx, startY + vy);
        ctx.strokeStyle = 'rgba(0,255,0,.5)'; ctx.lineWidth = 1; ctx.stroke();
    }
    
    if (addVelocityMode) {
        if (addVelToolState === 'drawing' || addVelToolState === 'locked' || addVelToolState === 'applyingVelocity') {
            const box = selectionBox.screen;
            if (box) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
                ctx.fillRect(box.x, box.y, box.w, box.h);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(box.x, box.y, box.w, box.h);
                ctx.setLineDash([]);
            }
        }
        
        if (addVelToolState === 'applyingVelocity') {
            const box = selectionBox.screen;
            if (box) {
                const boxCenterX = box.x + box.w / 2;
                const boxCenterY = box.y + box.h / 2;

                const mouse_dx = cx - lockedBoxDragStart.x;
                const mouse_dy = cy - lockedBoxDragStart.y;

                const endX = boxCenterX + mouse_dx;
                const endY = boxCenterY + mouse_dy;

                ctx.beginPath(); ctx.moveTo(boxCenterX, boxCenterY); ctx.lineTo(endX, endY);
                ctx.strokeStyle = 'rgba(255,255,255,.5)'; ctx.lineWidth = 3; ctx.stroke();
                
                const vx_preview = -mouse_dx * 0.3 * THROW_MULT;
                const vy_preview = -mouse_dy * 0.3 * THROW_MULT;
                
                ctx.beginPath(); ctx.moveTo(boxCenterX, boxCenterY); ctx.lineTo(boxCenterX + vx_preview, boxCenterY + vy_preview);
                ctx.strokeStyle = 'rgba(0,255,0,.8)'; ctx.lineWidth = 2; ctx.stroke();
            }
        }
    }
    
    if (barycenterMode && barycenterBoxDrawing) {
        const box = selectionBox.screen;
        if(box) {
            ctx.fillStyle = 'rgba(170, 100, 255, 0.2)';
            ctx.fillRect(box.x, box.y, box.w, box.h);
            ctx.strokeStyle = 'rgba(170, 100, 255, 0.7)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(box.x, box.y, box.w, box.h);
            ctx.setLineDash([]);
        }
    }
    ctx.restore();
}
function loop(){ 
    if (!isPaused) {
        step();
    }
    
    // Cleanup selectedParticles if a particle was deleted/merged
    if (selectedParticles.size > 0) {
        const currentParticles = Array.from(selectedParticles).filter(p => ps.includes(p));
        if (currentParticles.length !== selectedParticles.size) {
            selectedParticles = new Set(currentParticles);
        }
    }

    if (dragging && orbitPredictionEnabled) {
        const w = screenToWorld(sx, sy);
        let vx = (sx - cx) * 0.5 * THROW_MULT / zoom;
        let vy = (sy - cy) * 0.5 * THROW_MULT / zoom;
        if (trackedParticle) { vx += trackedParticle.vx; vy += trackedParticle.vy; }
        const ghost = { x: w.x, y: w.y, m: SPAWN_MASS, vx: vx, vy: vy };
        spawnPreviewPath = predictSpawnPath(ghost, ps, trackedParticle);
    }
    
    if (addVelocityMode && addVelToolState === 'locked') {
        if (selectedParticles.size === 0) {
            addVelToolState = 'idle';
            selectionBox.screen = null;
        }
    }

    if (orbitPredictionEnabled) {
        predictAllOrbits();
    }
    
    draw(); 
    requestAnimationFrame(loop); 
}

/* ---------- UI ---------- */
function $(id){ return document.getElementById(id); }
const sliders={
    gravitySlider:     {el:$('gravitySlider'),     val:$('gravityValue'),     def:DEFAULT_G,   suffix:''},
    gravityMultSlider: {el:$('gravityMultSlider'), val:$('gravityMultValue'), def:DEFAULT_GM,  suffix:'×'},
    timeSlider:        {el:$('timeSlider'),        val:$('timeValue'),        def:DEFAULT_TS,  suffix:'×'},
    spawnMassSlider:   {el:$('spawnMassSlider'),   val:$('spawnMassValue'),   def:DEFAULT_SM,  suffix:''},
    throwSpeedMultSlider:{el:$('throwSpeedMultSlider'),val:$('throwSpeedMultValue'),def:DEFAULT_TSM, suffix:'×'},
    pathLengthSlider: {el:$('pathLengthSlider'),val:$('pathLengthValue'),def:DEFAULT_PATH_MULT, suffix:''}
};
let isEditingValue = false;

function wire(){
    for(const k in sliders){
        const s = sliders[k];
        const sliderKey = k;

        s.el.value = s.def;
        s.val.textContent = (k==='spawnMassSlider' || k==='pathLengthSlider' ? s.def : s.def.toFixed(1))+(s.suffix || '');
        
        s.el.addEventListener('input',()=>{
            if (isEditingValue) return;
            const v = parseFloat(s.el.value);
            s.val.textContent = (k==='spawnMassSlider' || k==='pathLengthSlider' ? v : v.toFixed(1))+(s.suffix || '');
            
            if(k==='gravitySlider') G=v;
            if(k==='gravityMultSlider') GM=v;
            if(k==='timeSlider') TS=v;
            if(k==='spawnMassSlider') SPAWN_MASS=v;
            if(k==='throwSpeedMultSlider') THROW_MULT=v;
            if(k==='pathLengthSlider') PATH_LENGTH_MULTIPLIER=v;
        });

        s.val.addEventListener('click', () => {
            if (isEditingValue) return;
            isEditingValue = true;
            let enterPressed = false;

            const originalValue = parseFloat(s.el.value);
            const span = s.val;
            const parent = span.parentNode;
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'value-input';
            input.value = originalValue;
            
            parent.replaceChild(input, span);
            input.focus();
            input.select();

            const applyValue = (newValue) => {
                if(sliderKey==='gravitySlider') G=newValue;
                if(sliderKey==='gravityMultSlider') GM=newValue;
                if(sliderKey==='timeSlider') TS=newValue;
                if(sliderKey==='spawnMassSlider') SPAWN_MASS=newValue;
                if(sliderKey==='throwSpeedMultSlider') THROW_MULT=newValue;
                if(sliderKey==='pathLengthSlider') PATH_LENGTH_MULTIPLIER=newValue;

                s.el.value = newValue;
                span.textContent = (sliderKey === 'spawnMassSlider' || sliderKey === 'pathLengthSlider' ? newValue : newValue.toFixed(1)) + (s.suffix || '');
            };

            const finishEditing = (applyChanges) => {
                let finalValue = originalValue;
                if (applyChanges) {
                    const typedValue = parseFloat(input.value);
                    if (!isNaN(typedValue) && typedValue >= 0) {
                        finalValue = typedValue;
                    }
                }
                applyValue(finalValue);
                parent.replaceChild(span, input);
                isEditingValue = false;
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    enterPressed = true;
                    finishEditing(true);
                } else if (e.key === 'Escape') {
                    finishEditing(false);
                }
            };

            const handleBlur = () => {
                if (enterPressed) return;
                finishEditing(false);
            };

            input.addEventListener('keydown', handleKeyDown);
            input.addEventListener('blur', handleBlur);
        });
    }
}
wire();

$('clearAllButton').onclick = resetPs;
$('resetAllButton').onclick=()=>{
    for(const k in sliders) {
        sliders[k].el.value = sliders[k].def;
        sliders[k].el.dispatchEvent(new Event('input'));
    }
};
$('pauseButton').onclick=(e)=>{
    isPaused = !isPaused;
    e.target.textContent = isPaused ? 'Resume' : 'Pause';
};

/* ---------- Object List ---------- */
function updateObjectList() {
    const listDiv = $('object-list');
    if (!listDiv) return;
    ps.sort((a, b) => b.m - a.m);

    let html = '';
    for (const p of ps) {
        const isTrackedClass = (trackedParticle && p.id === trackedParticle.id) ? 'tracked' : '';
        if (p.isBarycenter) {
             const isHiddenClass = !p.visible ? 'hidden-vis' : '';
             html += `
                <div class="object-item ${isTrackedClass}" data-id="${p.id}">
                    <div class="color-swatch" style="border: 2px dashed rgba(255,255,255,0.5); background: none; box-sizing: border-box;"></div>
                    <div class="info">
                        <div><b>${p.name || `Body #${p.id}`}</b></div>
                        <div>Total Mass: ${p.m.toFixed(1)}</div>
                        <div>Bodies: ${p.connectedIds.length}</div>
                    </div>
                    <button class="toggle-vis-btn ${isHiddenClass}" data-id="${p.id}">👁️</button>
                    <button class="edit-btn" data-id="${p.id}">✎</button>
                    <button class="delete-btn" data-id="${p.id}">X</button>
                </div>`;
        } else {
            const speed = Math.sqrt(p.vx*p.vx + p.vy*p.vy).toFixed(2);
            const direction = (Math.atan2(p.vy, p.vx) * 180 / Math.PI).toFixed(1);
            const diameter = (p.r * 2).toFixed(2);
            html += `
                <div class="object-item ${isTrackedClass}" data-id="${p.id}">
                    <div class="color-swatch" style="background-color: ${p.color()};"></div>
                    <div class="info">
                        <div><b>${p.name || `Body #${p.id}`}</b></div>
                        <div>Mass: ${p.m.toFixed(1)}</div>
                        <div>Diameter: ${diameter}</div>
                        <div>Vel: ${speed} @ ${direction}°</div>
                    </div>
                    <button class="edit-btn" data-id="${p.id}">✎</button>
                    <button class="delete-btn" data-id="${p.id}">X</button>
                </div>`;
        }
    }
    listDiv.innerHTML = html;
}
$('object-list').addEventListener('click', (e) => {
    const item = e.target.closest('.object-item');
    if (!item) return;

    const id = parseInt(item.dataset.id);
    if (isNaN(id)) return;
    const p_clicked = ps.find(p => p.id === id);
    if (!p_clicked) return;

    if (e.target.classList.contains('delete-btn')) {
        recordHistory({ type: 'delete', particle: cloneParticle(p_clicked) });
        if (trackedParticle && trackedParticle.id === id) setTrackedParticle(null);
        if (currentlyEditing && currentlyEditing.id === id) hideEditPanel();
        ps = ps.filter(p => p.id !== id);
    } else if (e.target.classList.contains('edit-btn')) {
        showEditPanel(p_clicked);
    } else if (e.target.classList.contains('toggle-vis-btn')) {
        if (p_clicked.isBarycenter) {
            p_clicked.visible = !p_clicked.visible;
            e.target.classList.toggle('hidden-vis', !p_clicked.visible);
        }
    } else {
        setTrackedParticle(p_clicked);
    }
});
setInterval(updateObjectList, 250);

/* ---------- Utilities Toolbar ---------- */
$('utilitiesButton').onclick = () => {
    $('utilitiesToolbar').classList.toggle('expanded');
};

function deactivateAllTools(except = null) {
    if (except !== 'tracker') { planetTrackerMode = false; $('trackerBtn').classList.remove('active'); }
    if (except !== 'editor') { planetEditorMode = false; $('editorBtn').classList.remove('active'); hideEditPanel(); }
    if (except !== 'addVel') { addVelocityMode = false; $('addVelBtn').classList.remove('active'); addVelToolState = 'idle'; selectedParticles.clear(); }
    if (except !== 'anchor') { anchorMode = false; $('anchorBtn').classList.remove('active'); }
    if (except !== 'barycenter') { barycenterMode = false; $('barycenterBtn').classList.remove('active'); barycenterBoxDrawing = false; selectionBox = {world:null, screen:null}; selectedParticles.clear(); }
    if (except !== 'saveLoad') { hideSaveLoadPanel(); }
    if (except !== 'presets') { hidePresetsPanel(); }
    if (except !== 'autoOrbit') { autoOrbitMode = false; $('autoOrbitBtn').classList.remove('active'); }
}

function clearAllVisualAids() {
    ps.forEach(p => p.trail = []);
    predictedPaths.clear();
    spawnPreviewPath = [];
}

function setTrackedParticle(newParticle) {
    if (trackedParticle === newParticle) return; // No change, do nothing.

    clearAllVisualAids();
    trackedParticle = newParticle;

    if (newParticle) {
        if (!planetTrackerMode) {
            deactivateAllTools('tracker');
            planetTrackerMode = true;
            $('trackerBtn').classList.add('active');
        }
    } else { // newParticle is null
        if (planetTrackerMode) {
            planetTrackerMode = false;
            $('trackerBtn').classList.remove('active');
        }
        if (relativeTrailsEnabled) {
            relativeTrailsEnabled = false;
            $('relTrailBtn').classList.remove('active');
        }
    }
}


$('trackerBtn').onclick = (e) => {
    planetTrackerMode = !planetTrackerMode;
    if (planetTrackerMode) { 
        deactivateAllTools('tracker'); 
        e.target.classList.add('active'); 
    } else { 
        setTrackedParticle(null);
    }
};
$('addVelBtn').onclick = (e) => {
    addVelocityMode = !addVelocityMode;
    if (addVelocityMode) { deactivateAllTools('addVel'); e.target.classList.add('active'); } 
    else { e.target.classList.remove('active'); }
};
$('anchorBtn').onclick = (e) => {
    anchorMode = !anchorMode;
    if (anchorMode) { deactivateAllTools('anchor'); e.target.classList.add('active'); } 
    else { e.target.classList.remove('active'); }
};
$('autoOrbitBtn').onclick = (e) => {
    if (e.target.classList.contains('disabled')) return;
    autoOrbitMode = !autoOrbitMode;
    if (autoOrbitMode) {
        deactivateAllTools('autoOrbit');
        e.target.classList.add('active');
    } else {
        e.target.classList.remove('active');
    }
};
$('trailsBtn').onclick = (e) => {
    trailsEnabled = !trailsEnabled;
    e.target.classList.toggle('active', trailsEnabled);
    if(trailsEnabled) {
        clearAllVisualAids();
        orbitPredictionEnabled = false; relativeTrailsEnabled = false;
        $('orbitBtn').classList.remove('active'); $('relTrailBtn').classList.remove('active');
    }
};
$('relTrailBtn').onclick = (e) => {
    if (!trackedParticle) {
        relativeTrailsEnabled = false;
        e.target.classList.remove('active');
        return;
    }
    relativeTrailsEnabled = !relativeTrailsEnabled;
    e.target.classList.toggle('active', relativeTrailsEnabled);
    if(relativeTrailsEnabled) {
        clearAllVisualAids();
        trailsEnabled = false; orbitPredictionEnabled = false;
        $('trailsBtn').classList.remove('active'); $('orbitBtn').classList.remove('active');
    }
};
$('orbitBtn').onclick = (e) => {
    orbitPredictionEnabled = !orbitPredictionEnabled;
    e.target.classList.toggle('active', orbitPredictionEnabled);
    if (orbitPredictionEnabled) {
        clearAllVisualAids();
        trailsEnabled = false; relativeTrailsEnabled = false;
        $('trailsBtn').classList.remove('active'); $('relTrailBtn').classList.remove('active');
    } else {
        predictedPaths.clear();
    }
};
$('editorBtn').onclick = (e) => {
    planetEditorMode = !planetEditorMode;
    if(planetEditorMode){ deactivateAllTools('editor'); e.target.classList.add('active'); } 
    else { e.target.classList.remove('active'); hideEditPanel(); }
};
$('barycenterBtn').onclick = (e) => {
    barycenterMode = !barycenterMode;
    if (barycenterMode) { deactivateAllTools('barycenter'); e.target.classList.add('active'); }
    else { e.target.classList.remove('active'); }
};

/* ---------- Planet Editor Panel ---------- */
function showEditPanel(p) {
    if (!p) return;
    currentlyEditing = p;
    const panel = $('edit-panel');
    $('edit-id').value = p.id;
    $('edit-name').value = p.name || '';
    $('edit-mass').value = p.m;
    $('edit-mass').disabled = p.isBarycenter;
    $('edit-color').value = p.customColor || '#ffffff';
    $('edit-color').disabled = p.isBarycenter;
    
    panel.style.display = 'block';
    panel.style.left = `${(window.innerWidth - panel.offsetWidth) / 2}px`;
    panel.style.top = `${(window.innerHeight - panel.offsetHeight) / 2}px`;
}
function hideEditPanel() {
    currentlyEditing = null;
    $('edit-panel').style.display = 'none';
}
$('saveEditBtn').onclick = () => {
    const p = ps.find(p => p.id === parseInt($('edit-id').value));
    if(p) {
        const beforeState = { id: p.id, name: p.name, m: p.m, r: p.r, customColor: p.customColor };
        
        p.name = $('edit-name').value || ("Body " + p.id);
        if (!p.isBarycenter) {
            p.m = Math.max(1, parseFloat($('edit-mass').value));
            p.r = Math.sqrt(p.m);
            p.customColor = $('edit-color').value;
        }

        const afterState = { id: p.id, name: p.name, m: p.m, r: p.r, customColor: p.customColor };
        recordHistory({type: 'edit', before: beforeState, after: afterState});
    }
    hideEditPanel();
};
$('cancelEditBtn').onclick = hideEditPanel;

// Draggable Panel Logic
let isDraggingPanel = false, panelOffsetX, panelOffsetY;
const editPanel = $('edit-panel');
const editPanelHeader = $('edit-panel-header');

editPanelHeader.addEventListener('mousedown', e => {
    isDraggingPanel = true;
    panelOffsetX = e.clientX - editPanel.offsetLeft;
    panelOffsetY = e.clientY - editPanel.offsetTop;
    e.preventDefault();
});
document.addEventListener('mousemove', e => {
    if (!isDraggingPanel) return;
    let newX = e.clientX - panelOffsetX;
    let newY = e.clientY - panelOffsetY;
    
    newX = Math.max(0, Math.min(newX, window.innerWidth - editPanel.offsetWidth));
    newY = Math.max(0, Math.min(newY, window.innerHeight - editPanel.offsetHeight));

    editPanel.style.left = `${newX}px`;
    editPanel.style.top = `${newY}px`;
});
document.addEventListener('mouseup', () => { isDraggingPanel = false; });

/* ---------- Save, Load, and Preset Logic ---------- */
function loadSimulationData(data) {
    try {
        if (data.version !== "1.0") {
            throw new Error(`Incompatible version. Expected "1.0", got "${data.version}".`);
        }
        if (!data.sliders || !data.particles || !data.settings) {
            throw new Error("Invalid simulation file structure.");
        }

        bodyNameCounter = 1;

        // Restore Sliders
        G = data.sliders.gravity; GM = data.sliders.gravityMult; TS = data.sliders.timeSpeed;
        SPAWN_MASS = data.sliders.spawnMass; THROW_MULT = data.sliders.throwSpeedMult; PATH_LENGTH_MULTIPLIER = data.sliders.pathLength;
        
        sliders.gravitySlider.el.value = G; sliders.gravityMultSlider.el.value = GM; sliders.timeSlider.el.value = TS;
        sliders.spawnMassSlider.el.value = SPAWN_MASS; sliders.throwSpeedMultSlider.el.value = THROW_MULT; sliders.pathLengthSlider.el.value = PATH_LENGTH_MULTIPLIER;
        for (const k in sliders) sliders[k].el.dispatchEvent(new Event('input'));

        // Restore Particles
        let maxId = 0;
        ps = data.particles.map(p_data => {
            const newP = new P(0,0);
            Object.assign(newP, p_data);
            newP.r = Math.sqrt(newP.m); // Recalculate radius
            if (p_data.id > maxId) maxId = p_data.id;
            
            if (newP.name && newP.name.startsWith("Body ")) {
                const num = parseInt(newP.name.substring(5));
                if (!isNaN(num) && num >= bodyNameCounter) {
                    bodyNameCounter = num + 1;
                }
            }
            return newP;
        });
        nextId = maxId + 1;

        // Restore Settings
        isPaused = data.settings.isPaused; $('pauseButton').textContent = isPaused ? 'Resume' : 'Pause';
        trailsEnabled = data.settings.trailsEnabled; $('trailsBtn').classList.toggle('active', trailsEnabled);
        relativeTrailsEnabled = data.settings.relativeTrailsEnabled; $('relTrailBtn').classList.toggle('active', relativeTrailsEnabled);
        orbitPredictionEnabled = data.settings.orbitPredictionEnabled; $('orbitBtn').classList.toggle('active', orbitPredictionEnabled);

        const newTrackedParticle = data.trackedParticleId ? ps.find(p => p.id === data.trackedParticleId) || null : null;
        setTrackedParticle(newTrackedParticle);
        
        if (data.view) { zoom = data.view.zoom; viewX = data.view.viewX; viewY = data.view.viewY; } 
        else { zoom = DEFAULT_ZOOM; viewX = 0; viewY = 0; }

        resetHistory();
        return true;
    } catch (error) {
        alert(`Error loading simulation: ${error.message}`);
        return false;
    }
}

// Save & Load Panel
const saveLoadPanel = $('save-load-panel');
function showSaveLoadPanel() {
    deactivateAllTools('saveLoad');
    saveLoadPanel.style.display = 'flex';
    saveLoadPanel.style.left = `${(window.innerWidth - saveLoadPanel.offsetWidth) / 2}px`;
    saveLoadPanel.style.top = `${(window.innerHeight - saveLoadPanel.offsetHeight) / 2}px`;
}
function hideSaveLoadPanel() {
    saveLoadPanel.style.display = 'none';
    $('loadFileInput').value = ''; 
    $('fileNameSpan').textContent = 'no file chosen';
}
$('saveLoadBtn').onclick = (e) => {
    const isActive = saveLoadPanel.style.display === 'flex';
    if(isActive) hideSaveLoadPanel();
    else {
        e.target.classList.add('active'); showSaveLoadPanel(); setTimeout(() => e.target.classList.remove('active'), 200);
    }
};
$('closeSaveLoadBtn').onclick = hideSaveLoadPanel;
$('saveSimBtn').onclick = () => {
    const saveData = {
        version: "1.0", timestamp: Date.now(),
        sliders: { gravity: G, gravityMult: GM, timeSpeed: TS, spawnMass: SPAWN_MASS, throwSpeedMult: THROW_MULT, pathLength: PATH_LENGTH_MULTIPLIER },
        particles: ps.map(p => ({
            id: p.id, name: p.name, x: p.x, y: p.y, vx: p.vx, vy: p.vy, m: p.m, customColor: p.customColor, anchored: p.anchored,
            isBarycenter: p.isBarycenter, connectedIds: p.connectedIds, visible: p.visible
        })),
        settings: { trailsEnabled, relativeTrailsEnabled, orbitPredictionEnabled, isPaused },
        trackedParticleId: trackedParticle?.id || null, view: { zoom, viewX, viewY }
    };
    const jsonString = JSON.stringify(saveData, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const timestamp = new Date().toISOString().replace(/:/g, '-').slice(0, 19);
    a.download = `simulation_${timestamp}.json`;
    a.href = url;
    a.click();
    URL.revokeObjectURL(url);
    hideSaveLoadPanel();
};
$('chooseFileBtn').onclick = () => $('loadFileInput').click();
$('loadFileInput').onchange = (e) => {
    const file = e.target.files[0];
    $('fileNameSpan').textContent = file ? file.name : 'no file chosen';
};
$('loadSimBtn').onclick = () => {
    const file = $('loadFileInput').files[0];
    if (!file) { alert('Please choose a file to load.'); return; }
    const reader = new FileReader();
    reader.onload = (e) => {
        const data = JSON.parse(e.target.result);
        if (loadSimulationData(data)) { hideSaveLoadPanel(); }
    };
    reader.onerror = () => alert('Error reading file.');
    reader.readAsText(file);
};

// Presets Panel
const presetsPanel = $('presets-panel');
function showPresetsPanel() {
    deactivateAllTools('presets');
    presetsPanel.style.display = 'flex';
    presetsPanel.style.left = `${(window.innerWidth - presetsPanel.offsetWidth) / 2}px`;
    presetsPanel.style.top = `${(window.innerHeight - presetsPanel.offsetHeight) / 2}px`;
}
function hidePresetsPanel() { presetsPanel.style.display = 'none'; }
$('presetsBtn').onclick = (e) => {
    const isActive = presetsPanel.style.display === 'flex';
    if(isActive) hidePresetsPanel();
    else {
        e.target.classList.add('active'); showPresetsPanel(); setTimeout(() => e.target.classList.remove('active'), 200);
    }
};
$('closePresetsBtn').onclick = hidePresetsPanel;

// Draggable Modals Logic (Combined for larger panels)
let draggedPanel = null, isDraggingModal = false;
function makePanelDraggable(panel, header) {
    header.addEventListener('mousedown', e => {
        if (e.target.tagName === 'BUTTON') return;
        draggedPanel = panel; isDraggingModal = true;
        panelOffsetX = e.clientX - draggedPanel.offsetLeft; panelOffsetY = e.clientY - draggedPanel.offsetTop;
        e.preventDefault();
    });
}
makePanelDraggable($('save-load-panel'), $('save-load-panel-header'));
makePanelDraggable($('presets-panel'), $('presets-panel-header'));
document.addEventListener('mousemove', e => {
    if (!isDraggingModal || !draggedPanel) return;
    let newX = e.clientX - panelOffsetX; let newY = e.clientY - panelOffsetY;
    newX = Math.max(0, Math.min(newX, window.innerWidth - draggedPanel.offsetWidth));
    newY = Math.max(0, Math.min(newY, window.innerHeight - draggedPanel.offsetHeight));
    draggedPanel.style.left = `${newX}px`; draggedPanel.style.top = `${newY}px`;
});
document.addEventListener('mouseup', () => { isDraggingModal = false; draggedPanel = null; });

// Preset Data & Loading
const PRESETS={"Solar System":{version:"1.0",sliders:{gravity:200,gravityMult:10,timeSpeed:1,spawnMass:10,throwSpeedMult:10,pathLength:550},particles:[{id:1,name:"Sun",x:0,y:0,vx:0,vy:0,m:1e6,customColor:"#FFD700",anchored:!1,isBarycenter:!1,visible:!0},{id:2,name:"Mercury",x:3900,y:0,vx:0,vy:716.11,m:.055,customColor:"#A9A9A9",anchored:!1,isBarycenter:!1,visible:!0},{id:3,name:"Venus",x:7200,y:0,vx:0,vy:527.05,m:.815,customColor:"#F4A460",anchored:!1,isBarycenter:!1,visible:!0},{id:4,name:"Earth",x:1e4,y:0,vx:0,vy:447.21,m:1,customColor:"#00BFFF",anchored:!1,isBarycenter:!1,visible:!0},{id:5,name:"Luna",x:10026,y:0,vx:0,vy:455.98,m:.0123,customColor:"#C0C0C0",anchored:!1,isBarycenter:!1,visible:!0},{id:6,name:"Mars",x:15200,y:0,vx:0,vy:362.74,m:.107,customColor:"#FF4500",anchored:!1,isBarycenter:!1,visible:!0},{id:7,name:"Jupiter",x:52e3,y:0,vx:0,vy:196.12,m:317.8,customColor:"#DAA520",anchored:!1,isBarycenter:!1,visible:!0},{id:8,name:"Saturn",x:95400,y:0,vx:0,vy:144.79,m:95.2,customColor:"#F0E68C",anchored:!1,isBarycenter:!1,visible:!0},{id:9,name:"Uranus",x:191800,y:0,vx:0,vy:102.12,m:14.5,customColor:"#ADD8E6",anchored:!1,isBarycenter:!1,visible:!0},{id:10,name:"Neptune",x:300300,y:0,vx:0,vy:81.61,m:17.1,customColor:"#00008B",anchored:!1,isBarycenter:!1,visible:!0},{id:11,name:"Pluto",x:395e3,y:0,vx:0,vy:71.16,m:.0022,customColor:"#A52A2A",anchored:!1,isBarycenter:!1,visible:!0}],settings:{trailsEnabled:!1,relativeTrailsEnabled:!0,orbitPredictionEnabled:!1,isPaused:!1},trackedParticleId:1},"Proxima Centauri System":{version:"1.0",sliders:{gravity:200,gravityMult:10,timeSpeed:1,spawnMass:10,throwSpeedMult:10,pathLength:550},particles:[{id:1,name:"Proxima Centauri",x:0,y:0,vx:0,vy:0,m:61e3,customColor:"#FF4500",anchored:!1,isBarycenter:!1,visible:!0},{id:2,name:"Proxima b",x:750,y:0,vx:0,vy:420,m:1.17,customColor:"#8B7355",anchored:!1,isBarycenter:!1,visible:!0},{id:3,name:"Proxima c",x:3200,y:0,vx:0,vy:185,m:7,customColor:"#4682B4",anchored:!1,isBarycenter:!1,visible:!0},{id:4,name:"Proxima d",x:370,y:0,vx:0,vy:680,m:.26,customColor:"#DAA520",anchored:!1,isBarycenter:!1,visible:!0}],settings:{trailsEnabled:!1,relativeTrailsEnabled:!0,orbitPredictionEnabled:!1,isPaused:!1},trackedParticleId:1},"TRAPPIST-1 System":{version:"1.0",sliders:{gravity:200,gravityMult:10,timeSpeed:1,spawnMass:10,throwSpeedMult:10,pathLength:550},particles:[{id:1,name:"TRAPPIST-1",x:0,y:0,vx:0,vy:0,m:4e4,customColor:"#8B0000",anchored:!1,isBarycenter:!1,visible:!0},{id:2,name:"b",x:115,y:0,vx:0,vy:834.06,m:1.02,customColor:"#B22222",anchored:!1,isBarycenter:!1,visible:!0},{id:3,name:"c",x:155,y:0,vx:0,vy:718.42,m:1.16,customColor:"#DC143C",anchored:!1,isBarycenter:!1,visible:!0},{id:4,name:"d",x:215,y:0,vx:0,vy:609.99,m:.41,customColor:"#FF4500",anchored:!1,isBarycenter:!1,visible:!0},{id:5,name:"e",x:285,y:0,vx:0,vy:529.81,m:.77,customColor:"#FFD700",anchored:!1,isBarycenter:!1,visible:!0},{id:6,name:"f",x:375,y:0,vx:0,vy:461.88,m:1.04,customColor:"#32CD32",anchored:!1,isBarycenter:!1,visible:!0},{id:7,name:"g",x:460,y:0,vx:0,vy:417.03,m:1.32,customColor:"#4682B4",anchored:!1,isBarycenter:!1,visible:!0},{id:8,name:"h",x:610,y:0,vx:0,vy:362.14,m:.33,customColor:"#708090",anchored:!1,isBarycenter:!1,visible:!0}],settings:{trailsEnabled:!1,relativeTrailsEnabled:!0,orbitPredictionEnabled:!1,isPaused:!1},trackedParticleId:1},"Kepler-186 System":{version:"1.0",sliders:{gravity:200,gravityMult:10,timeSpeed:1,spawnMass:10,throwSpeedMult:10,pathLength:550},particles:[{id:1,name:"Kepler-186",x:0,y:0,vx:0,vy:0,m:22e4,customColor:"#FFA500",anchored:!1,isBarycenter:!1,visible:!0},{id:2,name:"b",x:850,y:0,vx:0,vy:719.48,m:1.7,customColor:"#B22222",anchored:!1,isBarycenter:!1,visible:!0},{id:3,name:"c",x:1150,y:0,vx:0,vy:618.55,m:2.1,customColor:"#DC143C",anchored:!1,isBarycenter:!1,visible:!0},{id:4,name:"d",x:1550,y:0,vx:0,vy:532.8,m:2.4,customColor:"#FF4500",anchored:!1,isBarycenter:!1,visible:!0},{id:5,name:"e",x:2100,y:0,vx:0,vy:457.74,m:1.5,customColor:"#32CD32",anchored:!1,isBarycenter:!1,visible:!0},{id:6,name:"f",x:3100,y:0,vx:0,vy:376.74,m:1.4,customColor:"#228B22",anchored:!1,isBarycenter:!1,visible:!0}],settings:{trailsEnabled:!1,relativeTrailsEnabled:!0,orbitPredictionEnabled:!1,isPaused:!1},trackedParticleId:1},"55 Cancri System":{version:"1.0",sliders:{gravity:200,gravityMult:10,timeSpeed:1,spawnMass:10,throwSpeedMult:10,pathLength:550},particles:[{id:1,name:"55 Cancri",x:0,y:0,vx:0,vy:0,m:48e4,customColor:"#FFD700",anchored:!1,isBarycenter:!1,visible:!0},{id:2,name:"b",x:1800,y:0,vx:0,vy:730.3,m:260,customColor:"#FF4500",anchored:!1,isBarycenter:!1,visible:!0},{id:3,name:"c",x:3800,y:0,vx:0,vy:502.62,m:54,customColor:"#DAA520",anchored:!1,isBarycenter:!1,visible:!0},{id:4,name:"f",x:7500,y:0,vx:0,vy:357.77,m:46,customColor:"#32CD32",anchored:!1,isBarycenter:!1,visible:!0},{id:5,name:"d",x:24e3,y:0,vx:0,vy:200,m:1200,customColor:"#8B0000",anchored:!1,isBarycenter:!1,visible:!0},{id:6,name:"e",x:350,y:0,vx:0,vy:1656.16,m:8.6,customColor:"#B22222",anchored:!1,isBarycenter:!1,visible:!0}],settings:{trailsEnabled:!1,relativeTrailsEnabled:!0,orbitPredictionEnabled:!1,isPaused:!1},trackedParticleId:1},"Kepler-11 System":{version:"1.0",sliders:{gravity:200,gravityMult:10,timeSpeed:1,spawnMass:10,throwSpeedMult:10,pathLength:550},particles:[{id:1,name:"Kepler-11",x:0,y:0,vx:0,vy:0,m:475e3,customColor:"#FFFF00",anchored:!1,isBarycenter:!1,visible:!0},{id:2,name:"b",x:1100,y:0,vx:0,vy:929.32,m:4.3,customColor:"#B22222",anchored:!1,isBarycenter:!1,visible:!0},{id:3,name:"c",x:1500,y:0,vx:0,vy:795.82,m:13.5,customColor:"#DC143C",anchored:!1,isBarycenter:!1,visible:!0},{id:4,name:"d",x:1950,y:0,vx:0,vy:697.98,m:6.1,customColor:"#FF4500",anchored:!1,isBarycenter:!1,visible:!0},{id:5,name:"e",x:2500,y:0,vx:0,vy:616.44,m:8.4,customColor:"#FFD700",anchored:!1,isBarycenter:!1,visible:!0},{id:6,name:"f",x:3300,y:0,vx:0,vy:536.54,m:2.3,customColor:"#32CD32",anchored:!1,isBarycenter:!1,visible:!0},{id:7,name:"g",x:4800,y:0,vx:0,vy:444.88,m:300,customColor:"#4682B4",anchored:!1,isBarycenter:!1,visible:!0}],settings:{trailsEnabled:!1,relativeTrailsEnabled:!0,orbitPredictionEnabled:!1,isPaused:!1},trackedParticleId:1},"Kepler-47 System":{version:"1.0",sliders:{gravity:200,gravityMult:10,timeSpeed:1,spawnMass:10,throwSpeedMult:10,pathLength:550},particles:[{id:1,name:"Kepler-47 A",x:-200,y:0,vx:0,vy:0,m:5e5,customColor:"#FFD700",anchored:!1,isBarycenter:!1,visible:!0},{id:2,name:"Kepler-47 B",x:200,y:0,vx:0,vy:0,m:1e5,customColor:"#FFA500",anchored:!1,isBarycenter:!1,visible:!0},{id:3,name:"b",x:4500,y:0,vx:0,vy:516.4,m:2,customColor:"#32CD32",anchored:!1,isBarycenter:!1,visible:!0},{id:4,name:"c",x:12e3,y:0,vx:0,vy:316.23,m:23,customColor:"#4682B4",anchored:!1,isBarycenter:!1,visible:!0}],settings:{trailsEnabled:!1,relativeTrailsEnabled:!0,orbitPredictionEnabled:!1,isPaused:!1},trackedParticleId:1}};

function populatePresetsPanel() {
    const container = $('presets-container');
    container.innerHTML = ''; // Clear previous
    for (const presetName in PRESETS) {
        const btn = document.createElement('button');
        btn.className = 'preset-item-btn';
        btn.textContent = presetName;
        btn.dataset.presetKey = presetName;
        container.appendChild(btn);
    }
}
$('presets-container').addEventListener('click', e => {
    if (e.target.classList.contains('preset-item-btn')) {
        const presetKey = e.target.dataset.presetKey;
        if (PRESETS[presetKey] && loadSimulationData(PRESETS[presetKey])) {
            hidePresetsPanel();
        }
    }
});

/* ---------- mouse controls ---------- */
function getParticleAtScreenPos(x, y) {
    const worldPos = screenToWorld(x,y);
    for (const p of ps.slice().reverse()) {
        if (p.isBarycenter) continue;
        const dx = p.x - worldPos.x;
        const dy = p.y - worldPos.y;
        if (dx*dx + dy*dy < p.r*p.r) return p;
    }
    return null;
}

function isPointInWorldBox(px, py, box) {
    if (!box) return false;
    return px >= box.x && px <= box.x + box.w && py >= box.y && py <= box.y + box.h;
}

function isPointInRect(px, py, rect) {
    if (!rect) return false;
    return px >= rect.x && px <= rect.x + rect.w && py >= rect.y && py <= rect.y + rect.h;
}

canvas.addEventListener('contextmenu', e => e.preventDefault());
canvas.addEventListener('mousedown', e => {
    const clickedParticle = getParticleAtScreenPos(e.clientX, e.clientY);
    sx = e.clientX; sy = e.clientY;
    
    if (e.button !== 0) {
        if (trackedParticle) { setTrackedParticle(null); }
        isPanning = true;
        lastX = e.clientX; lastY = e.clientY;
        return;
    }

    if (barycenterMode && e.ctrlKey) {
        if (clickedParticle && !clickedParticle.isBarycenter) {
            if (selectedParticles.has(clickedParticle)) {
                selectedParticles.delete(clickedParticle);
            } else {
                selectedParticles.add(clickedParticle);
            }
        }
        return;
    }
    
    if (autoOrbitMode) { return; }

    if (planetTrackerMode && clickedParticle) { setTrackedParticle(clickedParticle); return; }
    if (planetEditorMode && clickedParticle) { showEditPanel(clickedParticle, e); return; }

    if (addVelocityMode) {
        if (addVelToolState === 'locked') {
            if (isPointInRect(e.clientX, e.clientY, selectionBox.screen)) {
                addVelToolState = 'applyingVelocity';
                lockedBoxDragStart = { x: e.clientX, y: e.clientY };
                return;
            } else {
                addVelToolState = 'idle'; selectedParticles.clear(); selectionBox.screen = null;
            }
        }
        
        if (clickedParticle) {
            addVelTarget = clickedParticle; cx = e.clientX; cy = e.clientY;
        } else {
            addVelToolState = 'drawing'; selectionBox.screen = { x: e.clientX, y: e.clientY, w: 0, h: 0 };
        }
        return;
    }
    if (anchorMode) {
        if (clickedParticle) {
            const beforeState = { id: clickedParticle.id, anchored: clickedParticle.anchored };
            clickedParticle.anchored = !clickedParticle.anchored;
            const afterState = { id: clickedParticle.id, anchored: clickedParticle.anchored };
            recordHistory({ type: 'anchor', before: beforeState, after: afterState });
        }
        return;
    }
    
    if (barycenterMode) {
        if (!clickedParticle) {
            barycenterBoxDrawing = true; selectionBox.screen = { x: e.clientX, y: e.clientY, w: 0, h: 0 };
        }
        return;
    }
    
    if (planetEditorMode) return;

    dragging = true;
    cx = e.clientX;
    cy = e.clientY;
});

canvas.addEventListener('mousemove', e => {
    if (isPanning) {
        viewX -= (e.clientX - lastX) / zoom;
        viewY -= (e.clientY - lastY) / zoom;
        lastX = e.clientX; lastY = e.clientY;
    } else {
        cx = e.clientX; cy = e.clientY;
        if (addVelocityMode && addVelToolState === 'drawing') {
            selectionBox.screen.w = e.clientX - selectionBox.screen.x;
            selectionBox.screen.h = e.clientY - selectionBox.screen.y;
        } else if (barycenterMode && barycenterBoxDrawing) {
            selectionBox.screen.w = e.clientX - selectionBox.screen.x;
            selectionBox.screen.h = e.clientY - selectionBox.screen.y;
        }
    }
});
canvas.addEventListener('mouseup', e => {
    if (e.button === 2) { isPanning = false; return; }
    const isSimpleClick = Math.hypot(e.clientX - sx, e.clientY - sy) < 5;
    
    if (autoOrbitMode && trackedParticle && !trackedParticle.isBarycenter && !isPanning) {
        const w = screenToWorld(e.clientX, e.clientY);
        const spawnRadius = Math.sqrt(SPAWN_MASS);
        const r = Math.hypot(w.x - trackedParticle.x, w.y - trackedParticle.y);
        
        if (r < trackedParticle.r + spawnRadius) return;
        
        const EG = G * GM;
        const totalMass = trackedParticle.m + SPAWN_MASS;
        const v = Math.sqrt((EG * totalMass) / r);
        const angle = Math.atan2(w.y - trackedParticle.y, w.x - trackedParticle.x);
        
        let vx = -v * Math.sin(angle) + trackedParticle.vx;
        let vy = v * Math.cos(angle) + trackedParticle.vy;
        
        const newParticle = new P(w.x, w.y, SPAWN_MASS, vx, vy);
        newParticle.name = "Body " + bodyNameCounter++;
        ps.push(newParticle);
        recordHistory({ type: 'spawn', particle: cloneParticle(newParticle) });
        return;
    }

    if (barycenterMode) {
        if (barycenterBoxDrawing) {
            barycenterBoxDrawing = false;
            const r = { l: Math.min(sx, cx), r: Math.max(sx, cx), t: Math.min(sy, cy), b: Math.max(sy, cy) };
            const w_tl = screenToWorld(r.l, r.t);
            const w_br = screenToWorld(r.r, r.b);
            selectionBox.world = {x: w_tl.x, y: w_tl.y, w: w_br.x - w_tl.x, h: w_br.y - w_tl.y };

            ps.forEach(p => {
                if (!p.isBarycenter && isPointInWorldBox(p.x, p.y, selectionBox.world)) {
                    selectedParticles.add(p);
                }
            });
            selectionBox = { world: null, screen: null };
        } else if (isSimpleClick && !getParticleAtScreenPos(e.clientX, e.clientY)) {
             selectedParticles.clear();
        }
        return;
    }

    if (addVelocityMode) {
        if (addVelTarget) {
            const vx = (sx - e.clientX) * 0.3 * THROW_MULT / zoom;
            const vy = (sy - e.clientY) * 0.3 * THROW_MULT / zoom;
            
            const beforeState = { id: addVelTarget.id, vx: addVelTarget.vx, vy: addVelTarget.vy };
            addVelTarget.vx += vx; addVelTarget.vy += vy;
            const afterState = { id: addVelTarget.id, vx: addVelTarget.vx, vy: addVelTarget.vy };

            recordHistory({ type: 'addVelocity', before: beforeState, after: afterState });
            addVelTarget = null;

        } else if (addVelToolState === 'drawing') {
            const box = selectionBox.screen;
            const r = { l: Math.min(box.x, box.x + box.w), r: Math.max(box.x, box.x + box.w),
                        t: Math.min(box.y, box.y + box.h), b: Math.max(box.y, box.y + box.h) };
            
            selectionBox.screen = {x: r.l, y: r.t, w: r.r - r.l, h: r.b - r.t};

            if (selectionBox.screen.w < 5 && selectionBox.screen.h < 5) {
                addVelToolState = 'idle'; selectionBox.screen = null; return;
            }

            const w_tl = screenToWorld(r.l, r.t); const w_br = screenToWorld(r.r, r.b);
            const world_box_selection = {x: w_tl.x, y: w_tl.y, w: w_br.x - w_tl.x, h: w_br.y - w_tl.y };
            
            selectedParticles.clear();
            ps.forEach(p => {
                if (!p.isBarycenter && isPointInWorldBox(p.x, p.y, world_box_selection)) {
                    selectedParticles.add(p);
                }
            });

            if (selectedParticles.size > 0) { addVelToolState = 'locked'; } 
            else { addVelToolState = 'idle'; selectionBox.screen = null; }

        } else if (addVelToolState === 'applyingVelocity') {
            const screen_dx = e.clientX - lockedBoxDragStart.x;
            const screen_dy = e.clientY - lockedBoxDragStart.y;
            
            const vx = -screen_dx * 0.3 * THROW_MULT / zoom;
            const vy = -screen_dy * 0.3 * THROW_MULT / zoom;
            
            const beforeStates = [], afterStates = [];
            selectedParticles.forEach(p => {
                beforeStates.push({ id: p.id, vx: p.vx, vy: p.vy });
                p.vx += vx; p.vy += vy;
                afterStates.push({ id: p.id, vx: p.vx, vy: p.vy });
            });
            if (beforeStates.length > 0) {
                recordHistory({ type: 'batchEdit', before: beforeStates, after: afterStates });
            }
            addVelToolState = 'locked';
        }
        return;
    }
    
    if (dragging) {
        dragging = false;
        spawnPreviewPath = [];
        const w = screenToWorld(sx, sy);
        let vx = (sx - e.clientX) * 0.5 * THROW_MULT / zoom;
        let vy = (sy - e.clientY) * 0.5 * THROW_MULT / zoom;
        if(trackedParticle) { vx += trackedParticle.vx; vy += trackedParticle.vy; }
        
        const newParticle = new P(w.x, w.y, SPAWN_MASS, vx, vy);
        newParticle.name = "Body " + bodyNameCounter++;
        ps.push(newParticle);
        recordHistory({ type: 'spawn', particle: cloneParticle(newParticle) });
    }
});

canvas.addEventListener('dblclick', e => {
    if (getParticleAtScreenPos(e.clientX, e.clientY)) return;
    setTrackedParticle(null);
});

window.addEventListener('keydown', e => {
    if (document.activeElement.tagName === 'INPUT' || isEditingValue) return;
    if (e.ctrlKey && e.key.toLowerCase() === 'z') { e.preventDefault(); undo(); }
    if (e.ctrlKey && e.key.toLowerCase() === 'y') { e.preventDefault(); redo(); }
    if(e.code === 'Space') {
        e.preventDefault(); isPaused = !isPaused; $('pauseButton').textContent = isPaused ? 'Resume' : 'Pause';
    }
    if (e.key === 'Enter' && barycenterMode) {
        e.preventDefault();
        if (selectedParticles.size >= 2) {
            let totalMass = 0, comX = 0, comY = 0;
            const ids = [];
            selectedParticles.forEach(p => {
                totalMass += p.m;
                comX += p.m * p.x;
                comY += p.m * p.y;
                ids.push(p.id);
            });
            const barycenter = new P(comX / totalMass, comY / totalMass, totalMass);
            barycenter.isBarycenter = true;
            barycenter.connectedIds = ids;
            barycenter.name = "Body " + bodyNameCounter++;
            ps.push(barycenter);
            recordHistory({ type: 'spawn', particle: cloneParticle(barycenter) });
        }
        selectedParticles.clear();
    }
    if (e.key === 'Escape') {
        hideEditPanel(); hideSaveLoadPanel(); hidePresetsPanel();
        deactivateAllTools();
    }
});

canvas.addEventListener('mouseleave', () => { isPanning = false; dragging = false; addVelTarget = null; spawnPreviewPath = []; addVelToolState = 'idle'; });
canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const worldBefore = screenToWorld(e.clientX, e.clientY);
    zoom *= (e.deltaY < 0 ? 1.1 : 0.9);
    zoom = Math.min(100, zoom);
    const worldAfter = screenToWorld(e.clientX, e.clientY);
    viewX += worldBefore.x - worldAfter.x;
    viewY += worldBefore.y - worldAfter.y;
});

function setupTooltips() {
    const tooltip = document.createElement('div');
    tooltip.className = 'tooltip';
    document.body.appendChild(tooltip);

    const TOOL_DESCRIPTIONS = {
        trackerBtn: "Click a planet to center and follow it with the camera.",
        addVelBtn: "Click and drag from a planet to apply velocity, or select multiple with a box.",
        anchorBtn: "Click a planet to freeze it in place while preserving its gravity.",
        autoOrbitBtn: "Spawn planets in perfect circular orbits around a tracked planet.",
        trailsBtn: "Show trails behind moving planets. Incompatible with other trail/orbit modes.",
        relTrailBtn: "Show trails relative to the tracked planet. Requires tracking a planet.",
        orbitBtn: "Predict and display the future orbital paths of all planets.",
        editorBtn: "Click a planet to edit its mass, name, and color.",
        barycenterBtn: "Select multiple planets (Ctrl+Click or box) and press Enter to create their center of mass.",
        saveLoadBtn: "Save your simulation to a file or load a previous save.",
        presetsBtn: "Load pre-made solar systems and exoplanet configurations."
    };

    document.querySelectorAll('#utilitiesToolbar .tool-btn').forEach(btn => {
        const description = TOOL_DESCRIPTIONS[btn.id];
        if (!description) return;

        btn.addEventListener('mouseenter', () => {
            if (btn.classList.contains('disabled')) return;
            tooltip.textContent = description;
            const rect = btn.getBoundingClientRect();
            
            tooltip.classList.remove('below');
            let top = rect.top - 10;
            let transform = `translateX(-50%) translateY(-100%) scale(0.95)`;

            tooltip.style.left = `${rect.left + rect.width / 2}px`;
            tooltip.style.top = `${top}px`;
            tooltip.style.transform = transform;
            
            // Re-check position after applying transform to get rendered position
            const tooltipRect = tooltip.getBoundingClientRect();
            if (tooltipRect.top < 5) {
                tooltip.classList.add('below');
                tooltip.style.top = `${rect.bottom + 10}px`;
                tooltip.style.transform = 'translateX(-50%) scale(0.95)';
            }
            
            tooltip.classList.add('show');
        });

        btn.addEventListener('mouseleave', () => {
            tooltip.classList.remove('show');
        });
    });
    // Hide tooltip if toolbar itself is left
    $('utilitiesToolbar').addEventListener('mouseleave', () => tooltip.classList.remove('show'));
}


/* ---------- start ---------- */
populatePresetsPanel();
setupTooltips();
resetPs();
loop();
</script>
</body>
</html>
